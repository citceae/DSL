1.输出format舍弃函数形式 因为函数形式每次一大串 中间缺少了去重 整体全都采用非终结符形式
2.本来以为有损的结果不太会有可以去重而判定不到的 但是效率同样不够高 瓶颈可能在一些复杂表达式在z3内部的判断等价性上 还是需要利用输入赋值做树状去重【TODO】
3.看的tree-based GP没有找到可以参考的 说的都是中间节点是op 叶节点是值 类似于四则运算的树状表达
4.接1 用一些随机展开和手工构造的展开进行测试 
发现产生式的顺序极大的影响效果 初始采用的是长度短的产生式靠前 其他按照字母序（o1版本） 有一些变好有一些变坏（有一个eusolver变得特别好）但是分析不出为什么有的变好有的变差 观察之后发现文法的顺序影响了枚举顺序（如把- SS放在了以下+的前面因为它长度短）
于是进行了第一次顺序调整 重点在于维持+在-之前 由于初步实现的粗糙 没有保证其他更细致的顺序（o2版本） 有一些变好有一些变坏 仍然发现有一些顺序发生了变化（进一步导致反例不同进一步很大的影响了后续）
自定义字符比较顺序后给出目前基本维持了原来的顺序的版本（o3版本 省略）是理论上能说清楚的顺序版本 效果obe上一致的变差了 且反例和产生程序顺序完全一致。 给出了一些理论的分析。
可能有用的结论：顺序是影响 至少obe的表现的一个很大的feature （但是改变这个的影响是不可理论分析的）

（想不起来之前优化了且反例和程序完全一致的是哪个版本了 去搜索了这个版本 即nonnewv：51.03s（vs原始61.47s）（输出文件见nonnewv.txt） 观察输出发现优化主要集中在把StartBool的一个<=去掉了 即z3发现 对于ite B S S展开B之后得到的一些项之中 ite (< S S) S S 和ite （<= S S） S S 等价 只需要将后两个S的位置交换即可 因此nonnewv去掉了<=定义出一个新的非终结符 同时保留了StartBool本身的结果 在这个启发下 如果直接在原文法StartBool中去掉<= 原文法可以直接加快到49.55s  输出文件见originrefine.txt
可能的启发：这种直接删除且不影响原文法表达形式和表达能力的肯定有效果）

一些最后的实验现象：
eusolver:
mpg_guard2_(改变了顺序为01xyz）： 99.02s
t0o1: 3.36s  （这个展开几乎没干什么事情）
m2o2: 30.68s
m4o1: 34.94s

mpg_guard2(原始版 顺序为xyz01）：54.88s
manual2:356.59s
manual4:76.08s
--------------------------------
obe：
原始：61.47  （origin.txt）
S+S完全展开(manual2)：76.74 （full.txt）
S+S部分展开(manual4)：76.00  (part.txt)

改变了一些顺序后（01xyz 上述是xyz01）
mpg_guard2_(即原始版）：215.995 （v2origin.txt） (注：后续跑eusolver可能不小心覆盖了这个的out文件）
S+S完全展开顺序2(m2o2)：95.50 （v2fullo2.txt）
S+S部分展开顺序1(m4o1)：81.29  (v2parto1.txt)

分析：为什么会下降
原本的理论: 
S->S+S|p|q 生成规模为2的程序时，构造出四个程序p+p,p+q,q+p,q+q,在这里S做一次去重把p+q|q+p保留一个；
新文法 S->S0|p|q S0->p+q|p+p|q+q 为了找到S生成的大小为2的程序，通过S0构造出三个程序，在S->S0这一步再被构造一次（不能直接复用吗），一共构造了6次

实际的情况：
S->S+S|p|q
新文法 S->S+S+S|p+S|q+S|p|q S->S+S+S|p+S+S|p+p|p+q|q+S+S|q+p|q+q|p|q
去重后改为非终结符形式：(P,Q是因为eusolver的文法检查的限制）
S->N1+S|P+N1|Q+N1|P+Q|P+P|Q+Q|p|q
N1->S+S
P->p
Q->q
考虑大小为2的程序，原文法先构造出p,q为S可以生成的大小为1的程序；而后构造出p+p|p+q|q+p|q+q四个大小为2的程序；一共经历了6次构造
新文法同理，先得知S可以构造出p，q；再得知P可以构造出p，Q可以构造出q；而后构造出p+q|p+p|q+q三个程序；一共经历了7次构造

继续考虑大小为3的，（不确定）原文法在内部去重后指导S可以构造出三个不一样的大小为2的程序；利用S+S,2+1的形式展开得到p+p+p|p+p+q|p+q+p|p+q+q|q+q+p|q+q+q,如果1+2也会被搜索那就再重复一次，一共构造出12个大小为3的程序
新文法中已知S可以构造p|q，p+q|p+p|q+q;为了得到S的大小为3的程序，按照产生式分配，需要先指导N1可以得到的大小为2的程序，这里额外又构造了p+q|...等四个，并去重成为3个；而后N1+S构造3*2个，P+N1构造3个，Q+N1构造3个 一共构造出12个大小为3的程序 但是额外多了N1的大小为2的程序即4个 一共16个构造 这本来是我们去掉的目标
（这里是假定以S能展开出规模为x的程序这个目标 on demand的去计算其他非终结符的构造情况）
换句话说为了表达形式的完整性 所有想在S+S里删掉的东西 都会在另一个非终结符中完全重复一遍 因此必然没有效果
有没有不引入这个代价的方法
