workflow:
1）生成训练程序。在训练集上用已有的程序合成求解器求解出大量的源语言上的
训练程序。本文中使用基于空间表示的程序合成求解器 MaxFlash 生成字符串处
理领域的训练程序。本文所使用的源语言是一个用于求解字符串处理问题的、
用上下文无关文法表达的、强类型的领域特定语言。
2）在训练程序上挖掘程序结构信息。包括训练程序中常见的模式、语法组件出现
的频率等。本文使用了频繁子树挖掘的方法挖掘训练程序中的常见模式。
3）将上一步挖掘到的程序结构抽象成语法上的修改操作，这些操作主要包含添加
语法组件、删除语法组件、对语法组件加以展开深度限制等。
4）利用搜索算法，找到一个由一系列修改操作组成的集合，使经过这些操作修改
的新语法相较源语言更优。本文方法的搜索过程分为两部分，首先使用估计函
数和遗传算法粗粒度地筛选出新语言的若干候选，再用直接测量求解时间的方
法在候选语言中选出最优的一个

TODO：
1.频繁子树挖掘算法
 1.1.将训练程序编码为前序树 done
 1.2.在前序树上进行频繁模式挖掘 done
2.抽象成修改操作
 2.1.添加根据频繁子树
 2.2.删除：统计频率删除某个阈值以下
 2.3.统计最大深度
3.估计函数和遗传算法
 3.1.编码修改操作生成对应的DSL half done
 3.2.对一个DSL计算适应度 适应度计算根据适应度函数有一些需要快速获取的信息 如按照枚举顺序目标程序的排序和删除了多少

1.1 编码方式 识别操作符和常量（编码成固定编号） 构造对应前序树
输入为多个解的字符串表示 输出为前序树（done）
1.2 频繁模式挖掘 利用github找到的一个CCtreeminer库（done）
https://github.com/zakimjz/SLEUTH
1left:收集多个解 多个训练任务 每个任务的多个解

2.1.需要去除一些参数（或者应该把参数都抽象成同一个如para0），主要挖掘的是操作符和操作符，操作符和常量之间组合得到的频繁模式（而且只拿到子树需要填充缺失的节点） 展示
 已有的result.txt里可以找到如 + 1 para1 但是更明显的可能需要把para1位置更改成统一的某个量 TODO
2.2.
2.3.根据得到的多个解 统计操作符的使用次数和终结符的最大深度 限深（？这个应该只加在非终结符上 如SLIA里就只有ntstring ntint ntbool三个终结符需要考虑深度？）
2left与1相同 拿到训练集对应的多个解后即可（训练集样本大小？多个训练程序*每个k个解）


3.得到设定好的基因集合 共有L中增加，删除，限制深度操作后 L位的基因
 3.1根据基因生成对应的DSL（base.sl） p.s.如果start不相同 需要生成多个版本的base.sl （给定基因，生成对应的base.sl 小的demo done）
 根据base.sl对测试集的每个DSL生成对应的修改了常量参量版本的DSL TODO（裁剪之后填充常量参量应该也是ok的 或者预先硬编码各个训练程序的信息 直接生成对应不同版本的文件）
 3.2对DSL计算适应度 
 主要需要Num(n_i)即每个训练问题上最小的解在新文法上的排序 TODO
 3.3整体遗传算法框架
 --------------------------------------------------------------------

 频繁模式挖掘（之前人工统计好了 需要编码到文件）
 删除认为每一项都有可能
 最大深度稍微统计一下（还没搞）
 
 估计函数写完了（对每一个DSL，对训练集产生的每一个任务的多个程序，找到其最优的排序，结合其他给出分数）//见trainset 要么硬编码控制start？
 按遗传算法框架进行
 
 ----------------------------------------------------------------------














