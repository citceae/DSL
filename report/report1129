复现的问题：1.纯compose能够有效果 2.并没有提到顺序问题
原论文的分离实验是在BV上对eusolver等做的 
general 优化 对于string到底能不能得到一个比较general的DSL优化大部分task （考虑 compose和删除真的够限制深度） 
现在在string obe 40个task上测试出来纯compose有加速
origin：38*25.32s   compose1：39*15.82s 加速比=1.61   compose2:37*6.81 （19 22 39 fail内存问题） 加速比=3.71
origin和compose1的具体对比：
positive: 1 5 6 7 10 11 12 14 15 17 18 19(149vs>200) 20 21 23 27 29 30 31 32 34 36 37 = 23
negetive: 2 3 4 8 9 16 22(222vs104) 25 26 28 35 38 40 = 13
eq:13 24 33 39(fail）= 4
其中19为origin超时，compose1 time=149s
22为origin104，compose1 time=222s（虽然我的timeguard设置的是200s）
39二者都fail


上述结果还未使用删除和限制深度 compose的组件为肉眼根据这些测试集的结果提取出来的（存在overfit）
适当的删除应当是正面的 限制深度的实现目前存在一些工程问题TODO 自动化提取compose应该会在数据集上得到更多的组件 不搭配删除限深可能会导致本来可以求解的失败了
总体来说 在obe string的组合上应当相信compose的效果 可以着手复现
针对1.纯compose能够有效果，只要我们提取的组件相对足够多，对于较难的task尽量都有用到，那么整体上就会一个比较好看的平均加速比
针对2.并没有提到顺序问题，虽然之前的测试中发现改变了如常量参量顺序就能影响到obe或者尤其eusolver的表现，这里可以认为严格保留原序进行实验 compose的组件加到产生式靠前位置


一轮测试，40个tasks，timeout=200s，21：52-22：13，20min一轮 timeout可以改的小一点


TODO：
工程问题：
限制深度操作 和 目前实现的 1.obe修正枚举非终结符到start的距离 2.基于base.sl更改文法需要校正start symbol 存在冲突
base.sl留常量参量位置 方便aim grammar替换对应位置满足裁剪后的文法需求 修正距离考虑直接回退？（这样子效果应该更明显）
修改成为单文件用脚本外框（main.py脚本模仿）
复现！



更多测试集和pattern（自动化） k个解的基础上挖掘
timeout以外的信息 或者 一般的 我们的timeout应该规定为什么
对于规模较大的测试 一旦用上了compose的东西或者删除了较多不影响的 加速效果会比较明显

1.根据task的一些feature 选择出一个合适的文法
2.在lxy基础上添加一个迭代加深的补丁 迭代大概率只需要1到2步 timeout可以设置的相对大 最不济的退回不删除的状态(工程问题)  遗传算法的诟病？ 适应度函数的问题？(增量计算)  复现【加优化】！！！
3.不通用的比如开启obe动态提供信息

可能可以做的
1.每次加哪些项 近似二次曲线的最优化 离线train 在线优化
2.动态timeout predicate任务难度

 
