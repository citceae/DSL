泛化实验
随机抽取了40个 发现源语言并不完全一样 比如部分case源语言本身没有int.to.str和ite（这会导致eusolver拒绝求解） 或者 有的case是没有ite 而我们特意保留了string和int里的ite（可能会部分变得更复杂）
少女祈祷中 见excel结果

频繁模式自动化实验
------------------------------------------------------------
1.所有频繁模式转换成对应的所有可能的完整的树
2.去掉语义等价的树（如str.++不需要生成交换律可以去掉的产生式）
3.对树的距离的刻画 距离小于多少（子串关系）且频繁度下降在多少范围内时选用更精细的case
--------------------------------------------------------------------------------
1.先对频繁模式做剪枝 如果A是B的频繁模式延伸，且频繁度B>k(=0.8)*频繁度A，则去掉A 76->62
2.对于筛选剩下的频繁模式建树，去掉语义等价的（如交换律 包括与原始相比） 如 1 2 -2160 --> str.substr P0 (P0和一般S的区别在于P0可以获取一些地方参数相同的特征）
 一个频繁模式对应多个树的问题（将完全树的编码返回给频繁模式数据集检验 举例来说 频繁模式 0 0对应的是str.++ str.++，但是0 X... -1 0 和 0 0 -1 X...都会被提取成0 0）
 想要加一个条件叫做频繁模式的相对位置也是给定的（好像一般频繁模式不会满足这一个条件） 相当于把占位符也给到频繁模式里
 目前先 根据每一个频繁模式先建出所有可能的树（然后做 相同语义树的去重？)
 str.++、+、只生成第一个匹配的树（
 
3.额外的知识或者信息利用 如P0大部分都是string 所以str.substr P0 N N 而非str.substr S P0 N 如[['1', '2', '-1', '7', '2'], 418] 表示str.substr P0 str.len(P0) N 或者str.substr P0 N str.len(P0) 利用对str.substr的知识知道后者是合理的 如str.++是交换的 0 ...不需要生成多个树 

熊老师的建议 可以加入大量expert domain knowledge

提前建立树的节点类型（子节点数目和数据类型）


