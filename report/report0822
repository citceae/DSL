按照repeat=1_op2_tl=10.txt求出来的DSL 针对产生式S（忽略B的展开）做的一个简单测试
得到的语法就是原语法S的每一个产生式的第一个非终结符展开一次（有一点点去重）
constraint是一个非常简单的三个参数相加
预期行为是希望这样展开之后的语法和原来的语法行为类似
这里的行为具体指的是在weighted_obe中改动后得到的输出文本 这一文本目前理解为：对于当前要生成的规模为X的程序，我所遍历的规模小于X的子程序的组合；以及根据组合生成的规模为X的程序 （但是我不确定我这样的输出位置是不是最合适的 因为输出还有不太直观的感觉）
得到的结果是：
1.原来未改动的遍历次数最少 函数形式次之 非终结符形式再次之
2.其中非终结符形式需要注意把0和1提升为一个非终结符，这似乎体现了某种规模判断的不合理
3.!!!根据2做出了xyz01常量相关的修改总算进步了!从结果上看 原来的不管是函数形式还是直接根据函数形式改编而来的非终结符形式都影响到了程序规模的判断(原先因为函数的方式认不得x y z这种常数迫不得已） 只对S的修改在mpg_guard2上的表现略微下降 但是规模太大不能查看文档
4.讨论之后的代价分析：手动剪枝效果和obe非终结符内部去重的矛盾
-----------------------------------------------------------------------
1.解决了原来的展开冗余问题
2.从原来的函数形式 到非终结符形式1 再到非终结符形式2 其中前两种形式的效果不好可能意味着求解器的实现有一些bug
效果不好体现在一个简单任务枚举量的大小上 初始：函数：非终结符1：非终结符2 = 4809：6722：14151：1495
时间对比 初始：函数：非终结符1：非终结符2 = 0.040383：0.041951：0.052874：0.033994
3.但是放在规模大一些的任务上，如mpg_guard2.sl中，非终结符形式2仍然是下降的。
时间对比 初始：函数：非终结符2 = 45：1369：56
4.3的原因来自于，非终结符形式引入了新的非终结符，导致一些obe本来能做的去重（obe会对每一个非终结符内部做一次去重）被延后了，对应的也就是程序重复次数有变多
举例来说 原文法 S->S+S S->p|q 新文法 S->S0 S0->p+p|p+q|q+q （针对规模为2的程序解释去重延后）原文法中 S中会有pq组合一共四个程序被构建出来并内部去重 新文法中S0内部构建出了3个程序并内部去重，然后S->S0这一步也会把这三个程序再构造一遍并去重，因此一共构造了六次程序，效果反而下降了
5.最后一点改动，吉老师把obe里的去重加了一个cache，即每个程序先找一下cache里有没有执行过输入，如果有就拿出来，如果没有再执行输入。这一个改动过后，在mpg_guard2任务上，初始：非终结符2 = 64。13：51.28 。这个改动对初始不产生重复的是纯冗余调用cache，对新文法减少了执行次数。
总结：试图做的是一个general的通过改动文法对所有（基于枚举的？）求解方式有加速的方法 实际做下来最大的感受是 非常依赖于求解器一些内部的实现 （如非终结符1的效果差就是因为规模度量的问题）
