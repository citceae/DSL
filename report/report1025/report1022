运用了交换律之后，mpg_guard2中间的结果有一些变差（即构造的程序变多了）中间的程序和反例有一些区别 但是在最终正确答案的层级上构造的程序数目下降 最终找到了同一个答案且效果有提升
但是在easytest上所有枚举中间过程都变好了 看起来是变化成+ x Start等使得这些表达式的规模刻画变小了
将x修改成X后 中间的程序和反例严格符合原序 效果下降

上述为x的规模判断有误的bug 修改之后 一致的下降了（为什么呢）

一些因为obe内部去重解决掉的可能被展开的规则导致冗余 比如x和y相同被去重了
如counter example为【2,0,0】，目标为构造+ x z时，原文法的Start在大小为1的程序上构造了5个，即x y z 0 1，并将y和z做一次去重得到Start可以得到4个不同的大小为1的程序而后利用+S S和-S S一共构造4*4*2=32个程序，为了找到目标一共构造了37个
新文法中利用了零律直接去掉了+ 0 S，但是因为文法中写出了+x S|+y S|+z S|+1 S,同理在知道Start能构造4个不同的大小为1的程序后，也会构造出4*4 + 4*4 = 32，算上大小为1的5个一共37个程序
有点想不清楚细节的construct num  (575看起来是等于5+5*5*2+26*5*4的 但是519不懂怎么来的）
但是感觉重点其实仍然是 加入了创建的新的非终结符之后 所有后续的枚举都会在这个新的非终结符上花很多构造时间 即使这个构造是Start内部的子集
通过e.sl和o.sl的对比看出构造数目在不引入新的非终结符时下降明显
easytest.sl和easytest_ex2.sl对比可以看出 虽然在Start中产生了一定的下降 但是在N1里有极大的代价
mpg_guard2和mpg_guard2_ex2这一点更为明显

有没有可能不引入新的非终结符
可以直接复用N1 N2 但是这里的现象时 Start + N1 + N2 要大于原有的Start 都要稳定的大上一些...
3752329 vs 1376250+999824+1622958=3999032
575 vs 285+323=608

虽然不知道为什么但是eusolver上有提升（把-SS共用 从57提升到了48s） 是否复用N1都有提升 交换律可能对此有效

在原文法基础上的结合律等怎么encode... 他本身都不包含这个结合律的结构 展开多层 + (+ S S) S 与 + S (+ S S)只允许一个？

