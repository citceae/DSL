1.timeout设置成10(单位应该是ms) 对比展开一层并去重后的结果发现没有变化
没有找到直接让z3报告本次调用的时间代价的方法 可能可以通过计时器在调用前后都记录一下去求平均时间 也手动code了展开两层后一些比较复杂的式子 timeout=10可以prove出来

2.尝试了把展开一层后去重的结果直接给出一个DSL考察求解器的效果（以eusolver为例，但对DSL的读取应该是共通的过程）
比如展开式有（+ （+ S S) S)这样的式子，目前的parser并不接受直接在DSL主体部分直接写（+ （+ Start Start) Start)，而是需要写成 
	(define-fun func6 ((a1 Int) (a2 Int) (a3 Int) ) Int (+ (+ a1 a2 )a3 ))，
并在主体内加入一条(func6 Start Start Start )。另外按照函数方式定义时，可以将0或1这样的数字作为已知参数但不能将传入的x y z作为已知参数，因此 S -> (+ x S) 不能直接写成
	(define-fun func1 ((a1 Int) ) Int (+ x a1 ))
而是要引入一个只展开得到x的变量X后写成
	(define-fun func1 ((X Int) (a1 Int) ) Int (+ X a1 ))
理论上这些都套了一层可能会有额外的求解代价
又，理论上得到的97条产生式是在原来初始DSL规则展开一层后去重不丢失任何表达能力的结果，但是按照上述方式编码后，如果再将自带的(ite StartBool Start Start)该条规则去掉（理论上可以看depth_1_out.txt验证所有由这个规则生成的都可以由func_num生成展开一层后的形式），则在调用eusolver时会产生段错误，如果保留这一条规则，调用eusolver时会进入很复杂的求解序列并无法得到最后的求解结果（基于此我猜最后把这个bug修了表现也不好，因为func这样套上一层后求解器似乎不能很方便的按照从小到大的顺序枚举了？）

3.cegis方法替换一部分z3调用节约时间的过程，目前的想法是造一些事先给定的例子 比如test1=（1 2 3 4 5 6 7) (True False True) 对于（+ （+ S S) S) 它枚举三个S和1 2 3的对应关系得到输出的集合作为它在test1上的结果，利用多个测试把产生式过滤到不同的组内进一步只在组内调用z3做去重（TODO）

时间代价分析
用别的求解器
树的结构降低复杂度

nonterm数目进行简单剪枝
求解器parser相关 或者说如何让求解器能用上现在解出来的DSL
